<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Cloud Room Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Cloud Room Pro - Gi·∫£i ph√°p h·ªçp tr·ª±c tuy·∫øn, g·ªçi video nh√≥m, chat v√† chia s·∫ª m√†n h√¨nh nhanh ch√≥ng, b·∫£o m·∫≠t.">
  <meta name="keywords" content="cloud room, video call, chat tr·ª±c tuy·∫øn, h·ªçp online, chia s·∫ª m√†n h√¨nh, simple-peer">
  <meta name="author" content="Cloud Room Pro">

  <!-- Open Graph -->
  <meta property="og:title" content="Cloud Room Pro - H·ªçp tr·ª±c tuy·∫øn th√¥ng minh">
  <meta property="og:description" content="T·∫°o ph√≤ng h·ªçp, g·ªçi video, chat v√† chia s·∫ª m√†n h√¨nh ch·ªâ trong v√†i gi√¢y.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://khoitongdz.github.io/Pro/">
  <meta property="og:image" content="https://tse1.mm.bing.net/th/id/OIP.98EeoWyrRcHXvv0Ti90-1wHaQD?pid=Api">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Cloud Room Pro - H·ªçp tr·ª±c tuy·∫øn th√¥ng minh">
  <meta name="twitter:description" content="G·ªçi video, chat, chia s·∫ª m√†n h√¨nh d·ªÖ d√†ng v√† b·∫£o m·∫≠t.">
  <meta name="twitter:image" content="https://yourdomain.com/thumbnail.png">

  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Segoe UI, sans-serif;
      background: #0f172a;
      color: #fff;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 12px;
      text-align: center;
      background: #1e293b;
    }
    .main {
      flex: 1;
      display: flex;
      gap: 12px;
      padding: 12px;
    }
    .videos {
      flex: 3;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 10px;
      background: #000;
      border-radius: 12px;
      padding: 10px;
      overflow: auto;
    }
    video {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-radius: 12px;
      background: #111;
      transform: rotateY(0deg);
    }
    .sidebar {
      flex: 1;
      background: #1e293b;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      padding: 12px;
    }
    .roomBox {
      margin-bottom: 12px;
      display: flex;
      gap: 6px;
    }
    input, button {
      padding: 8px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
    }
    input {
      flex: 1;
    }
    button {
      background: linear-gradient(135deg, #3b82f6, #06b6d4);
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      transition: .2s;
    }
    button:hover {
      opacity: .85;
    }
    .chatBox {
      flex: 1;
      background: #0f172a;
      border-radius: 8px;
      padding: 6px;
      overflow-y: auto;
      margin: 6px 0;
    }
    .msg {
      margin: 4px 0;
    }
    .me {
      color: #3b82f6;
    }
    .peer {
      color: #06b6d4;
    }
    .error {
      color: #ef4444;
    }
    .controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    #qrcode {
      margin-top: 10px;
    }
    .userList {
      background: #0f172a;
      border-radius: 8px;
      padding: 6px;
      max-height: 120px;
      overflow-y: auto;
      margin: 6px 0;
      font-size: 14px;
    }
    .userList div {
      padding: 4px 0;
      border-bottom: 1px solid #1e293b;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .spotlight video {
      width: 100% !important;
      height: 400px !important;
    }
    .status {
      font-size: 12px;
      color: #9ca3af;
      margin-top: 6px;
    }
    .video-container {
      position: relative;
      width: 100%;
      height: 200px;
      background: #111;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 14px;
      text-align: center;
    }
    .video-label {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
    }
    .no-stream {
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 10px;
    }
  </style>
</head>
<body>
  <header><h2>üì± Cloud Room Pro</h2></header>
  <div class="main">
    <div class="videos" id="videos"></div>
    <div class="sidebar">
      <div class="roomBox">
        <button onclick="createRoom()">T·∫°o ph√≤ng</button>
        <input id="roomId" placeholder="Nh·∫≠p Room ID"/>
        <button onclick="joinRoom()">Join</button>
        <button onclick="retryMediaAccess()" style="background: #ef4444; display: none;" id="retryMediaBtn">Th·ª≠ l·∫°i Camera/Mic</button>
      </div>
      <div id="roomInfo"></div>
      <div class="status" id="status">ƒêang ch·ªù k·∫øt n·ªëi...</div>
      <canvas id="qrcode"></canvas>
      <div class="userList" id="users"></div>
      <div class="chatBox" id="chat"></div>
      <div class="controls">
        <input id="msg" placeholder="Tin nh·∫Øn..."/>
        <button onclick="sendMsg()">üí¨ G·ª≠i</button>
        <button id="micBtn" onclick="toggleMic()" disabled>üé§ Mic</button>
        <button id="camBtn" onclick="toggleCam()" disabled>üì∑ Cam</button>
        <button id="shareBtn" onclick="shareScreen()" disabled>üì∫ Share</button>
        <button onclick="toggleLayout()">üñº Layout</button>
      </div>
    </div>
  </div>

  <script>
    let myStream, roomId, myId, isHost = false;
    let peers = {}, usersList = {}, micOn = true, camOn = true, layout = "grid", screenStream = null;
    const ws = new WebSocket('wss://socketsbay.com/wss/v2/2/demo/');
    let reconnectAttempts = 0, maxReconnectAttempts = 5;

    function updateStatus(message, isError = donnay) {
      const statusEl = document.getElementById("status");
      statusEl.textContent = message;
      statusEl.className = `status ${isError ? 'error' : ''}`;
      console.log(`Status: ${message}`);
      document.getElementById("retryMediaBtn").style.display = isError && message.includes("camera/mic") ? "inline-block" : "none";
    }

    async function retryMediaAccess() {
      updateStatus("ƒêang th·ª≠ truy c·∫≠p l·∫°i camera/mic...");
      try {
        myStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        console.log("Local stream obtained:", myStream.getTracks());
        addVideo(myStream, myId, true);
        document.getElementById("micBtn").disabled = false;
        document.getElementById("camBtn").disabled = false;
        document.getElementById("shareBtn").disabled = false;
        updateStatus("ƒê√£ truy c·∫≠p camera/mic th√†nh c√¥ng");
        for (let id in peers) {
          peers[id].addStream(myStream);
        }
      } catch (err) {
        updateStatus("Kh√¥ng th·ªÉ truy c·∫≠p camera/mic: " + err.message, true);
        console.error("Media retry error:", err);
        try {
          myStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log("Fallback to audio-only stream:", myStream.getTracks());
          addVideo(myStream, myId, true);
          document.getElementById("micBtn").disabled = false;
          updateStatus("Kh√¥ng c√≥ camera, ch·ªâ s·ª≠ d·ª•ng mic");
          for (let id in peers) {
            peers[id].addStream(myStream);
          }
        } catch (audioErr) {
          updateStatus("Kh√¥ng th·ªÉ truy c·∫≠p mic: " + audioErr.message, true);
          console.error("Audio fallback error:", audioErr);
          addNoStreamPlaceholder(myId);
        }
      }
    }

    function createRoom() {
      if (location.protocol !== 'https:') {
        updateStatus("·ª®ng d·ª•ng y√™u c·∫ßu HTTPS ƒë·ªÉ truy c·∫≠p camera/mic. Vui l√≤ng ch·∫°y tr√™n HTTPS.", true);
        return;
      }
      roomId = "room-" + Math.random().toString(36).substr(2, 6);
      isHost = true;
      document.getElementById("roomId").value = roomId;
      document.getElementById("roomInfo").innerHTML = `Ph√≤ng: <b>${roomId}</b> (Ch·ªß ph√≤ng)`;
      QRCode.toCanvas(document.getElementById("qrcode"), window.location.href + "#" + roomId, { width: 100 }, err => {
        if (err) updateStatus("L·ªói t·∫°o QR code: " + err.message, true);
      });
      updateStatus("ƒê√£ t·∫°o ph√≤ng, ƒëang kh·ªüi t·∫°o k·∫øt n·ªëi...");
      initWebRTC();
    }

    function joinRoom() {
      if (location.protocol !== 'https:') {
        updateStatus("·ª®ng d·ª•ng y√™u c·∫ßu HTTPS ƒë·ªÉ truy c·∫≠p camera/mic. Vui l√≤ng ch·∫°y tr√™n HTTPS.", true);
        return;
      }
      roomId = document.getElementById("roomId").value.trim();
      if (!roomId.match(/^room-[a-z0-9]{6}$/)) {
        updateStatus("Room ID kh√¥ng h·ª£p l·ªá", true);
        return;
      }
      document.getElementById("roomInfo").innerHTML = `Join ph√≤ng: <b>${roomId}</b>`;
      QRCode.toCanvas(document.getElementById("qrcode"), window.location.href + "#" + roomId, { width: 100 }, err => {
        if (err) updateStatus("L·ªói t·∫°o QR code: " + err.message, true);
      });
      updateStatus("ƒêang tham gia ph√≤ng...");
      initWebRTC();
    }

    async function initWebRTC() {
      try {
        myId = "user-" + Math.random().toString(36).substr(2, 6);
        try {
          myStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          console.log("Local stream obtained:", myStream.getTracks());
          addVideo(myStream, myId, true);
          document.getElementById("micBtn").disabled = false;
          document.getElementById("camBtn").disabled = false;
          document.getElementById("shareBtn").disabled = false;
          addUser(myId, "B·∫°n");
          updateStatus("ƒê√£ k·∫øt n·ªëi, ch·ªù c√°c th√†nh vi√™n kh√°c...");
        } catch (err) {
          updateStatus("Kh√¥ng th·ªÉ truy c·∫≠p camera/mic: " + err.message, true);
          console.error("Media error:", err);
          try {
            myStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log("Fallback to audio-only stream:", myStream.getTracks());
            addVideo(myStream, myId, true);
            document.getElementById("micBtn").disabled = false;
            updateStatus("Kh√¥ng c√≥ camera, ch·ªâ s·ª≠ d·ª•ng mic");
            addUser(myId, "B·∫°n");
          } catch (audioErr) {
            updateStatus("Kh√¥ng th·ªÉ truy c·∫≠p mic: " + audioErr.message + ". B·∫°n c√≥ th·ªÉ tham gia ƒë·ªÉ chat v√† xem video.", true);
            console.error("Audio fallback error:", audioErr);
            addNoStreamPlaceholder(myId);
            addUser(myId, "B·∫°n");
          }
        }

        ws.onopen = () => {
          console.log("WebSocket connected");
          updateStatus("ƒê√£ k·∫øt n·ªëi v·ªõi WebSocket server");
          ws.send(JSON.stringify({ type: "join", roomId, userId: myId, name: "Ng∆∞·ªùi d√πng " + myId.slice(5) }));
          if (!isHost) connectToHost();
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.roomId !== roomId) return;
          if (data.type === "join" && isHost) {
            addUser(data.userId, data.name);
            initPeer(data.userId, true);
          }
          if (data.type === "signal") {
            if (peers[data.userId]) {
              peers[data.userId].signal(data.signal);
            } else {
              initPeer(data.userId, false, data.signal);
            }
          }
          if (data.type === "chat") logChat(data.msg, data.sender, "peer");
          if (data.type === "leave") removeUser(data.userId);
          if (data.type === "hostCmd") handleHostCmd(data);
        };

        ws.onerror = (err) => {
          updateStatus("L·ªói WebSocket: Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng.", true);
          console.error("WebSocket error:", err);
          scheduleReconnect();
        };

        ws.onclose = () => {
          updateStatus("M·∫•t k·∫øt n·ªëi WebSocket, ƒëang th·ª≠ k·∫øt n·ªëi l·∫°i...", true);
          console.warn("WebSocket disconnected");
          scheduleReconnect();
        };

      } catch (err) {
        updateStatus("L·ªói kh·ªüi t·∫°o k·∫øt n·ªëi: " + err.message, true);
        console.error("WebRTC init error:", err);
      }
    }

    function scheduleReconnect() {
      if (reconnectAttempts >= maxReconnectAttempts) {
        updateStatus("Kh√¥ng th·ªÉ k·∫øt n·ªëi l·∫°i WebSocket sau nhi·ªÅu l·∫ßn th·ª≠.", true);
        return;
      }
      const delay = Math.min(Math.pow(2, reconnectAttempts) * 1000, 30000);
      reconnectAttempts++;
      setTimeout(() => {
        updateStatus(`ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i WebSocket (l·∫ßn ${reconnectAttempts}/${maxReconnectAttempts})...`);
        const newWs = new WebSocket('wss://socketsbay.com/wss/v2/2/demo/');
        newWs.onopen = ws.onopen;
        newWs.onmessage = ws.onmessage;
        newWs.onerror = ws.onerror;
        newWs.onclose = ws.onclose;
        ws = newWs;
      }, delay);
    }

    function initPeer(peerId, initiator = false, signalData = null) {
      if (peers[peerId]) return;
      const peer = new SimplePeer({
        initiator,
        stream: myStream,
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'turn:openrelay.metered.ca:80', username: 'openrelay.project', credential: 'openrelay' },
            { urls: 'turn:openrelay.metered.ca:443', username: 'openrelay.project', credential: 'openrelay' }
          ]
        }
      });

      peer.on('signal', (data) => {
        ws.send(JSON.stringify({ type: 'signal', roomId, userId: peerId, signal: data }));
      });

      peer.on('stream', (stream) => {
        console.log(`Received stream from ${peerId}:`, stream.getTracks());
        addVideo(stream, peerId);
      });

      peer.on('error', (err) => {
        updateStatus(`L·ªói k·∫øt n·ªëi v·ªõi ${peerId}: ${err.message}`, true);
        console.error(`Peer error with ${peerId}:`, err);
        removeUser(peerId);
      });

      peer.on('close', () => {
        removeUser(peerId);
        delete peers[peerId];
      });

      if (signalData) peer.signal(signalData);
      peers[peerId] = peer;
    }

    function connectToHost() {
      const hostId = roomId.replace("room-", "user-");
      if (hostId !== myId) initPeer(hostId, true);
    }

    function sendMsg() {
      const msg = document.getElementById("msg").value.trim();
      if (!msg) return;
      const sender = "B·∫°n";
      logChat(msg, sender, "me");
      ws.send(JSON.stringify({ type: "chat", roomId, msg, sender }));
      document.getElementById("msg").value = "";
    }

    function logChat(msg, sender, who) {
      const div = document.createElement("div");
      div.className = `msg ${who}`;
      div.textContent = `${sender}: ${msg}`;
      document.getElementById("chat").appendChild(div);
      document.getElementById("chat").scrollTop = document.getElementById("chat").scrollHeight;
    }

    function addVideo(stream, id, self = false) {
      if (document.getElementById("v-" + id)) return;
      if (!stream.getVideoTracks().length && !self) {
        updateStatus(`Stream t·ª´ ${id} kh√¥ng c√≥ video`, true);
        console.warn(`No video tracks in stream for ${id}`);
        return;
      }

      const container = document.createElement("div");
      container.className = "video-container";
      container.id = "v-" + id;

      const video = document.createElement("video");
      video.srcObject = stream;
      video.autoplay = true;
      video.playsInline = true;
      if (self) video.muted = true;
      video.style.width = "100%";
      video.style.height = "100%";
      video.style.objectFit = "cover";

      const label = document.createElement("div");
      label.className = "video-label";
      label.textContent = self ? "B·∫°n" : usersList[id] || id;

      container.appendChild(video);
      container.appendChild(label);
      document.getElementById("videos").appendChild(container);

      video.addEventListener("loadedmetadata", () => {
        video.play().catch(err => {
          updateStatus(`L·ªói ph√°t video cho ${id}: ${err.message}`, true);
          console.error("Video playback error:", err);
        });
      });

      stream.getTracks().forEach(track => {
        track.onended = () => {
          if (document.getElementById("v-" + id)) {
            document.getElementById("v-" + id).remove();
            updateStatus(`Stream t·ª´ ${id} ƒë√£ k·∫øt th√∫c`);
          }
        };
      });

      console.log(`Added video for ${id}, tracks:`, stream.getTracks());
    }

    function addNoStreamPlaceholder(id) {
      if (document.getElementById("v-" + id)) return;
      const container = document.createElement("div");
      container.className = "video-container no-stream";
      container.id = "v-" + id;
      container.textContent = usersList[id] || id;

      const label = document.createElement("div");
      label.className = "video-label";
      label.textContent = id === myId ? "B·∫°n (Kh√¥ng c√≥ video)" : usersList[id] || id;

      container.appendChild(label);
      document.getElementById("videos").appendChild(container);
    }

    function toggleMic() {
      if (!myStream || !myStream.getAudioTracks().length) return;
      micOn = !micOn;
      myStream.getAudioTracks().forEach(track => track.enabled = micOn);
      document.getElementById("micBtn").style.opacity = micOn ? 1 : 0.5;
      updateStatus("Mic " + (micOn ? "b·∫≠t" : "t·∫Øt"));
    }

    function toggleCam() {
      if (!myStream || !myStream.getVideoTracks().length) return;
      camOn = !camOn;
      myStream.getVideoTracks().forEach(track => track.enabled = camOn);
      document.getElementById("camBtn").style.opacity = camOn ? 1 : 0.5;
      updateStatus("Camera " + (camOn ? "b·∫≠t" : "t·∫Øt"));
    }

    async function shareScreen() {
      try {
        if (screenStream) {
          screenStream.getTracks().forEach(track => track.stop());
          screenStream = null;
          document.getElementById("shareBtn").textContent = "üì∫ Share";
          updateStatus("ƒê√£ d·ª´ng chia s·∫ª m√†n h√¨nh");
          if (myStream) {
            for (let id in peers) {
              peers[id].removeStream(screenStream);
              if (myStream.getVideoTracks().length) {
                peers[id].addStream(myStream);
              }
            }
            const localVideo = document.getElementById("v-" + myId)?.querySelector("video");
            if (localVideo && myStream.getVideoTracks().length) {
              localVideo.srcObject = myStream;
            } else if (localVideo) {
              document.getElementById("v-" + myId).remove();
              addNoStreamPlaceholder(myId);
            }
          }
          return;
        }

        screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        console.log("Screen stream obtained:", screenStream.getTracks());
        document.getElementById("shareBtn").textContent = "üõë Stop Share";
        updateStatus("ƒêang chia s·∫ª m√†n h√¨nh");

        const localVideo = document.getElementById("v-" + myId);
        if (localVideo) {
          localVideo.innerHTML = "";
          const video = document.createElement("video");
          video.srcObject = screenStream;
          video.autoplay = true;
          video.playsInline = true;
          video.muted = true;
          video.style.width = "100%";
          video.style.height = "100%";
          video.style.objectFit = "cover";

          const label = document.createElement("div");
          label.className = "video-label";
          label.textContent = "B·∫°n (Chia s·∫ª m√†n h√¨nh)";
          localVideo.appendChild(video);
          localVideo.appendChild(label);

          video.addEventListener("loadedmetadata", () => {
            video.play().catch(err => {
              updateStatus("L·ªói ph√°t chia s·∫ª m√†n h√¨nh: " + err.message, true);
              console.error("Screen share playback error:", err);
            });
          });
        }

        for (let id in peers) {
          peers[id].removeStream(myStream);
          if (screenStream.getVideoTracks().length) {
            peers[id].addStream(screenStream);
          }
        }

        screenStream.getVideoTracks()[0].onended = () => {
          shareScreen();
        };
      } catch (err) {
        updateStatus("L·ªói chia s·∫ª m√†n h√¨nh: " + err.message, true);
        console.error("Screen sharing error:", err);
      }
    }

    function addUser(id, name = id) {
      if (usersList[id]) return;
      usersList[id] = name;
      updateUsers();
    }

    function removeUser(id) {
      delete usersList[id];
      if (document.getElementById("v-" + id)) {
        document.getElementById("v-" + id).remove();
      }
      if (peers[id]) {
        peers[id].destroy();
        delete peers[id];
      }
      updateUsers();
      ws.send(JSON.stringify({ type: "leave", roomId, userId: id }));
    }

    function updateUsers() {
      const box = document.getElementById("users");
      box.innerHTML = "<b>üë• Th√†nh vi√™n:</b><br>";
      Object.keys(usersList).forEach(id => {
        const row = document.createElement("div");
        row.innerHTML = `‚Ä¢ ${usersList[id]}`;
        if (isHost && id !== myId) {
          const controls = document.createElement("span");
          controls.innerHTML = ` <button onclick="sendHostCmd('${id}', 'mute')">üîá</button> <button onclick="sendHostCmd('${id}', 'cam')">üìµ</button>`;
          row.appendChild(controls);
        }
        box.appendChild(row);
      });
    }

    function toggleLayout() {
      const videos = document.getElementById("videos");
      if (layout === "grid") {
        layout = "spotlight";
        videos.classList.add("spotlight");
      } else {
        layout = "grid";
        videos.classList.remove("spotlight");
      }
    }

    function sendHostCmd(target, cmd) {
      ws.send(JSON.stringify({ type: "hostCmd", roomId, userId: target, cmd }));
    }

    function handleHostCmd(data) {
      if (data.cmd === "mute" && myStream) {
        myStream.getAudioTracks().forEach(track => track.enabled = false);
        micOn = false;
        document.getElementById("micBtn").style.opacity = 0.5;
        updateStatus("Ch·ªß ph√≤ng t·∫Øt mic c·ªßa b·∫°n");
      }
      if (data.cmd === "cam" && myStream) {
        myStream.getVideoTracks().forEach(track => track.enabled = false);
        camOn = false;
        document.getElementById("camBtn").style.opacity = 0.5;
        updateStatus("Ch·ªß ph√≤ng t·∫Øt camera c·ªßa b·∫°n");
      }
    }

    window.onbeforeunload = () => {
      ws.send(JSON.stringify({ type: "leave", roomId, userId: myId }));
      if (myStream) {
        myStream.getTracks().forEach(track => track.stop());
      }
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
      }
      for (let id in peers) {
        peers[id].destroy();
      }
    };

    // Auto-join room from URL hash
    if (window.location.hash) {
      const hashRoomId = window.location.hash.slice(1);
      if (hashRoomId.match(/^room-[a-z0-9]{6}$/)) {
        document.getElementById("roomId").value = hashRoomId;
        joinRoom();
      }
    }
  </script>
</body>
</html>
