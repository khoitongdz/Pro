<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Cloud Room Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Cloud Room Pro - Gi·∫£i ph√°p h·ªçp tr·ª±c tuy·∫øn, g·ªçi video nh√≥m, chat v√† chia s·∫ª m√†n h√¨nh nhanh ch√≥ng, b·∫£o m·∫≠t.">
  <meta name="keywords" content="cloud room, video call, chat tr·ª±c tuy·∫øn, h·ªçp online, chia s·∫ª m√†n h√¨nh, peerjs">
  <meta name="author" content="Cloud Room Pro">

  <!-- Open Graph -->
  <meta property="og:title" content="Cloud Room Pro - H·ªçp tr·ª±c tuy·∫øn th√¥ng minh">
  <meta property="og:description" content="T·∫°o ph√≤ng h·ªçp, g·ªçi video, chat v√† chia s·∫ª m√†n h√¨nh ch·ªâ trong v√†i gi√¢y.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://yourdomain.com">
  <meta property="og:image" content="https://yourdomain.com/thumbnail.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Cloud Room Pro - H·ªçp tr·ª±c tuy·∫øn th√¥ng minh">
  <meta name="twitter:description" content="G·ªçi video, chat, chia s·∫ª m√†n h√¨nh d·ªÖ d√†ng v√† b·∫£o m·∫≠t.">
  <meta name="twitter:image" content="https://yourdomain.com/thumbnail.png">

  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Segoe UI, sans-serif;
      background: #0f172a;
      color: #fff;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 12px;
      text-align: center;
      background: #1e293b;
    }
    .main {
      flex: 1;
      display: flex;
      gap: 12px;
      padding: 12px;
    }
    .videos {
      flex: 3;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 10px;
      background: #000;
      border-radius: 12px;
      padding: 10px;
      overflow: auto;
    }
    video {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-radius: 12px;
      background: #111;
      transform: rotateY(0deg); /* Fix for mirrored video */
    }
    .sidebar {
      flex: 1;
      background: #1e293b;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      padding: 12px;
    }
    .roomBox {
      margin-bottom: 12px;
      display: flex;
      gap: 6px;
    }
    input, button {
      padding: 8px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
    }
    input {
      flex: 1;
    }
    button {
      background: linear-gradient(135deg, #3b82f6, #06b6d4);
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      transition: .2s;
    }
    button:hover {
      opacity: .85;
    }
    .chatBox {
      flex: 1;
      background: #0f172a;
      border-radius: 8px;
      padding: 6px;
      overflow-y: auto;
      margin: 6px 0;
    }
    .msg {
      margin: 4px 0;
    }
    .me {
      color: #3b82f6;
    }
    .peer {
      color: #06b6d4;
    }
    .error {
      color: #ef4444;
    }
    .controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    #qrcode {
      margin-top: 10px;
    }
    .userList {
      background: #0f172a;
      border-radius: 8px;
      padding: 6px;
      max-height: 120px;
      overflow-y: auto;
      margin: 6px 0;
      font-size: 14px;
    }
    .userList div {
      padding: 4px 0;
      border-bottom: 1px solid #1e293b;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .spotlight video {
      width: 100% !important;
      height: 400px !important;
    }
    .status {
      font-size: 12px;
      color: #9ca3af;
      margin-top: 6px;
    }
    .video-container {
      position: relative;
      width: 100%;
      height: 200px;
      background: #111;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 14px;
      text-align: center;
    }
    .video-label {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <header><h2>üì± Cloud Room Pro</h2></header>
  <div class="main">
    <div class="videos" id="videos"></div>
    <div class="sidebar">
      <div class="roomBox">
        <button onclick="createRoom()">T·∫°o ph√≤ng</button>
        <input id="roomId" placeholder="Nh·∫≠p Room ID"/>
        <button onclick="joinRoom()">Join</button>
      </div>
      <div id="roomInfo"></div>
      <div class="status" id="status">ƒêang ch·ªù k·∫øt n·ªëi...</div>
      <canvas id="qrcode"></canvas>
      <div class="userList" id="users"></div>
      <div class="chatBox" id="chat"></div>
      <div class="controls">
        <input id="msg" placeholder="Tin nh·∫Øn..."/>
        <button onclick="sendMsg()">üí¨ G·ª≠i</button>
        <button id="micBtn" onclick="toggleMic()">üé§ Mic</button>
        <button id="camBtn" onclick="toggleCam()">üì∑ Cam</button>
        <button id="shareBtn" onclick="shareScreen()">üì∫ Share</button>
        <button onclick="toggleLayout()">üñº Layout</button>
      </div>
    </div>
  </div>

  <script>
    let peer, myStream, roomId, myId, isHost = false;
    let peers = {}, conns = {}, usersList = {}, micOn = true, camOn = true, layout = "grid", screenStream = null;

    function updateStatus(message, isError = false) {
      const statusEl = document.getElementById("status");
      statusEl.textContent = message;
      statusEl.className = `status ${isError ? 'error' : ''}`;
    }

    function createRoom() {
      roomId = "room-" + Math.random().toString(36).substr(2, 6);
      isHost = true;
      document.getElementById("roomId").value = roomId;
      document.getElementById("roomInfo").innerHTML = `Ph√≤ng: <b>${roomId}</b> (Ch·ªß ph√≤ng)`;
      QRCode.toCanvas(document.getElementById("qrcode"), window.location.href + "#" + roomId, { width: 100 }, err => {
        if (err) updateStatus("L·ªói t·∫°o QR code: " + err.message, true);
      });
      updateStatus("ƒê√£ t·∫°o ph√≤ng, ƒëang kh·ªüi t·∫°o k·∫øt n·ªëi...");
      startPeer();
    }

    function joinRoom() {
      roomId = document.getElementById("roomId").value.trim();
      if (!roomId.match(/^room-[a-z0-9]{6}$/)) {
        updateStatus("Room ID kh√¥ng h·ª£p l·ªá", true);
        return;
      }
      document.getElementById("roomInfo").innerHTML = `Join ph√≤ng: <b>${roomId}</b>`;
      QRCode.toCanvas(document.getElementById("qrcode"), window.location.href + "#" + roomId, { width: 100 }, err => {
        if (err) updateStatus("L·ªói t·∫°o QR code: " + err.message, true);
      });
      updateStatus("ƒêang tham gia ph√≤ng...");
      startPeer();
    }

    async function startPeer() {
      try {
        myId = "user-" + Math.random().toString(36).substr(2, 6);
        peer = new Peer(myId, {
          host: 'peerjs.com',
          secure: true,
          port: 443,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              // Replace with your TURN server for production
              // { urls: 'turn:your-turn-server', username: 'user', credential: 'pass' }
            ]
          }
        });

        peer.on("open", async () => {
          try {
            myStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            console.log("Local stream obtained:", myStream.getTracks());
            addVideo(myStream, myId, true);
            addUser(myId, "B·∫°n");
            updateStatus("ƒê√£ k·∫øt n·ªëi, ch·ªù c√°c th√†nh vi√™n kh√°c...");
            if (!isHost) {
              connectToRoomPeers();
            }
          } catch (err) {
            updateStatus("Kh√¥ng th·ªÉ truy c·∫≠p camera/mic: " + err.message, true);
            console.error("Media error:", err);
          }
        });

        peer.on("connection", conn => {
          conns[conn.peer] = conn;
          conn.on("data", data => {
            if (data.type === "chat") logChat(data.msg, data.sender, "peer");
            if (data.type === "join") addUser(data.id, data.name || data.id);
            if (data.type === "leave") removeUser(data.id);
            if (data.type === "hostCmd") handleHostCmd(data);
          });
          conn.on("close", () => {
            removeUser(conn.peer);
            delete conns[conn.peer];
          });
        });

        peer.on("call", call => {
          if (!myStream) {
            updateStatus("Kh√¥ng c√≥ stream ƒë·ªÉ tr·∫£ l·ªùi cu·ªôc g·ªçi", true);
            return;
          }
          call.answer(myStream);
          call.on("stream", stream => {
            console.log("Received remote stream:", stream.getTracks());
            addVideo(stream, call.peer);
          });
          call.on("close", () => removeUser(call.peer));
          call.on("error", err => updateStatus("L·ªói cu·ªôc g·ªçi: " + err.message, true));
          peers[call.peer] = call;
        });

        peer.on("error", err => {
          updateStatus("L·ªói PeerJS: " + err.message, true);
          console.error("PeerJS error:", err);
          setTimeout(reconnectPeer, 5000);
        });

        peer.on("disconnected", () => {
          updateStatus("M·∫•t k·∫øt n·ªëi, ƒëang th·ª≠ k·∫øt n·ªëi l·∫°i...", true);
          reconnectPeer();
        });

      } catch (err) {
        updateStatus("Kh√¥ng th·ªÉ kh·ªüi t·∫°o PeerJS: " + err.message, true);
        console.error("PeerJS init error:", err);
      }
    }

    function connectToRoomPeers() {
      const hostId = roomId.replace("room-", "user-"); // Simplified, assumes host ID format
      if (hostId !== myId) connectTo(hostId);
    }

    function connectTo(id) {
      if (conns[id] || id === myId) return;
      const conn = peer.connect(id);
      conns[id] = conn;
      conn.on("open", () => {
        conn.send({ type: "join", id: myId, name: "Ng∆∞·ªùi d√πng " + myId.slice(5) });
      });
      conn.on("data", data => {
        if (data.type === "chat") logChat(data.msg, data.sender, "peer");
        if (data.type === "join") addUser(data.id, data.name || data.id);
        if (data.type === "leave") removeUser(data.id);
        if (data.type === "hostCmd") handleHostCmd(data);
      });
      conn.on("close", () => {
        removeUser(id);
        delete conns[id];
        delete peers[id];
      });

      if (myStream) {
        const call = peer.call(id, myStream);
        call.on("stream", stream => {
          console.log("Received remote stream for call:", stream.getTracks());
          addVideo(stream, id);
        });
        call.on("close", () => removeUser(id));
        call.on("error", err => updateStatus("L·ªói cu·ªôc g·ªçi: " + err.message, true));
        peers[id] = call;
      }
    }

    function sendMsg() {
      const msg = document.getElementById("msg").value.trim();
      if (!msg) return;
      const sender = "B·∫°n";
      logChat(msg, sender, "me");
      for (let id in conns) {
        if (conns[id].open) {
          conns[id].send({ type: "chat", msg, sender });
        }
      }
      document.getElementById("msg").value = "";
    }

    function logChat(msg, sender, who) {
      const div = document.createElement("div");
      div.className = `msg ${who}`;
      div.textContent = `${sender}: ${msg}`;
      document.getElementById("chat").appendChild(div);
      document.getElementById("chat").scrollTop = document.getElementById("chat").scrollHeight;
    }

    function addVideo(stream, id, self = false) {
      if (document.getElementById("v-" + id)) return;
      if (!stream.getVideoTracks().length && !self) {
        updateStatus(`Stream t·ª´ ${id} kh√¥ng c√≥ video`, true);
        console.warn(`No video tracks in stream for ${id}`);
        return;
      }

      const container = document.createElement("div");
      container.className = "video-container";
      container.id = "v-" + id;

      const video = document.createElement("video");
      video.srcObject = stream;
      video.autoplay = true;
      video.playsInline = true;
      if (self) video.muted = true;
      video.style.width = "100%";
      video.style.height = "100%";
      video.style.objectFit = "cover";

      const label = document.createElement("div");
      label.className = "video-label";
      label.textContent = self ? "B·∫°n" : usersList[id] || id;

      container.appendChild(video);
      container.appendChild(label);
      document.getElementById("videos").appendChild(container);

      video.addEventListener("loadedmetadata", () => {
        video.play().catch(err => {
          updateStatus("L·ªói ph√°t video: " + err.message, true);
          console.error("Video playback error:", err);
        });
      });

      stream.getTracks().forEach(track => {
        track.onended = () => {
          if (document.getElementById("v-" + id)) {
            document.getElementById("v-" + id).remove();
            updateStatus(`Stream t·ª´ ${id} ƒë√£ k·∫øt th√∫c`);
          }
        };
      });

      console.log(`Added video for ${id}, tracks:`, stream.getTracks());
    }

    function toggleMic() {
      if (!myStream) return;
      micOn = !micOn;
      myStream.getAudioTracks().forEach(track => track.enabled = micOn);
      document.getElementById("micBtn").style.opacity = micOn ? 1 : 0.5;
      updateStatus("Mic " + (micOn ? "b·∫≠t" : "t·∫Øt"));
    }

    function toggleCam() {
      if (!myStream) return;
      camOn = !camOn;
      myStream.getVideoTracks().forEach(track => track.enabled = camOn);
      document.getElementById("camBtn").style.opacity = camOn ? 1 : 0.5;
      updateStatus("Camera " + (camOn ? "b·∫≠t" : "t·∫Øt"));
    }

    async function shareScreen() {
      try {
        if (screenStream) {
          screenStream.getTracks().forEach(track => track.stop());
          screenStream = null;
          document.getElementById("shareBtn").textContent = "üì∫ Share";
          updateStatus("ƒê√£ d·ª´ng chia s·∫ª m√†n h√¨nh");
          // Revert to camera stream
          if (myStream) {
            for (let id in peers) {
              const sender = peers[id].peerConnection.getSenders().find(s => s.track?.kind === "video");
              if (sender && myStream.getVideoTracks().length) {
                sender.replaceTrack(myStream.getVideoTracks()[0]);
              }
            }
            // Update local video to show camera
            const localVideo = document.getElementById("v-" + myId)?.querySelector("video");
            if (localVideo && myStream.getVideoTracks().length) {
              localVideo.srcObject = myStream;
            }
          }
          return;
        }

        screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        console.log("Screen stream obtained:", screenStream.getTracks());
        document.getElementById("shareBtn").textContent = "üõë Stop Share";
        updateStatus("ƒêang chia s·∫ª m√†n h√¨nh");

        // Update local video to show screen
        const localVideo = document.getElementById("v-" + myId)?.querySelector("video");
        if (localVideo) {
          localVideo.srcObject = screenStream;
        }

        // Replace video track for all peers
        for (let id in peers) {
          const sender = peers[id].peerConnection.getSenders().find(s => s.track?.kind === "video");
          if (sender && screenStream.getVideoTracks().length) {
            sender.replaceTrack(screenStream.getVideoTracks()[0]);
          }
        }

        screenStream.getVideoTracks()[0].onended = () => {
          shareScreen(); // Auto-stop sharing when user cancels
        };
      } catch (err) {
        updateStatus("L·ªói chia s·∫ª m√†n h√¨nh: " + err.message, true);
        console.error("Screen sharing error:", err);
      }
    }

    function addUser(id, name = id) {
      if (usersList[id]) return;
      usersList[id] = name;
      updateUsers();
    }

    function removeUser(id) {
      delete usersList[id];
      if (document.getElementById("v-" + id)) {
        document.getElementById("v-" + id).remove();
      }
      delete peers[id];
      delete conns[id];
      updateUsers();
    }

    function updateUsers() {
      const box = document.getElementById("users");
      box.innerHTML = "<b>üë• Th√†nh vi√™n:</b><br>";
      Object.keys(usersList).forEach(id => {
        const row = document.createElement("div");
        row.innerHTML = `‚Ä¢ ${usersList[id]}`;
        if (isHost && id !== myId) {
          const controls = document.createElement("span");
          controls.innerHTML = ` <button onclick="sendHostCmd('${id}', 'mute')">üîá</button> <button onclick="sendHostCmd('${id}', 'cam')">üìµ</button>`;
          row.appendChild(controls);
        }
        box.appendChild(row);
      });
    }

    function toggleLayout() {
      const videos = document.getElementById("videos");
      if (layout === "grid") {
        layout = "spotlight";
        videos.classList.add("spotlight");
      } else {
        layout = "grid";
        videos.classList.remove("spotlight");
      }
    }

    function sendHostCmd(target, cmd) {
      if (conns[target] && conns[target].open) {
        conns[target].send({ type: "hostCmd", cmd });
      }
    }

    function handleHostCmd(data) {
      if (data.cmd === "mute" && myStream) {
        myStream.getAudioTracks().forEach(track => track.enabled = false);
        micOn = false;
        document.getElementById("micBtn").style.opacity = 0.5;
        updateStatus("Ch·ªß ph√≤ng t·∫Øt mic c·ªßa b·∫°n");
      }
      if (data.cmd === "cam" && myStream) {
        myStream.getVideoTracks().forEach(track => track.enabled = false);
        camOn = false;
        document.getElementById("camBtn").style.opacity = 0.5;
        updateStatus("Ch·ªß ph√≤ng t·∫Øt camera c·ªßa b·∫°n");
      }
    }

    function reconnectPeer() {
      if (peer && peer.disconnected) {
        peer.reconnect();
        updateStatus("ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...");
      }
    }

    window.onbeforeunload = () => {
      for (let id in conns) {
        if (conns[id].open) {
          conns[id].send({ type: "leave", id: myId });
        }
      }
      if (myStream) {
        myStream.getTracks().forEach(track => track.stop());
      }
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
      }
      if (peer) peer.destroy();
    };

    // Auto-join room from URL hash
    if (window.location.hash) {
      const hashRoomId = window.location.hash.slice(1);
      if (hashRoomId.match(/^room-[a-z0-9]{6}$/)) {
        document.getElementById("roomId").value = hashRoomId;
        joinRoom();
      }
    }
  </script>
</body>
</html>
